jPS A:\> javap java.lang.Iterable      
Compiled from "Iterable.java"
public interface java.lang.Iterable<T> {
  public abstract java.util.Iterator<T> iterator();
  public default void forEach(java.util.function.Consumer<? super T>);
  public default java.util.Spliterator<T> spliterator();
}

================================================================================================================================================

PS A:\> javap java.util.Iterator

Compiled from "Iterator.java"
public interface java.util.Iterator<E> {
  public abstract boolean hasNext();  
  public abstract E next();
  public default void remove();       
  public default void forEachRemaining(java.util.function.Consumer<? super E>);
}

================================================================================================================================================

PS A:\> javap java.util.Spliterator
Compiled from "Spliterator.java"
public interface java.util.Spliterator<T> {
  public static final int ORDERED;    
  public static final int DISTINCT;   
  public static final int SORTED;     
  public static final int SIZED;      
  public static final int NONNULL;    
  public static final int IMMUTABLE;  
  public static final int CONCURRENT; 
  public static final int SUBSIZED;   
  public abstract boolean tryAdvance(java.util.function.Consumer<? super T>);
  public default void forEachRemaining(java.util.function.Consumer<? super T>);
  public abstract java.util.Spliterator<T> trySplit();
  public abstract long estimateSize();
  public default long getExactSizeIfKnown();
  public abstract int characteristics();
  public default boolean hasCharacteristics(int);
  public default java.util.Comparator<? super T> getComparator();
}
================================================================================================================================================

PS A:\> javap java.util.Collection
Compiled from "Collection.java"
public interface java.util.Collection<E> extends java.lang.Iterable<E> {    
  public abstract int size();
  public abstract boolean isEmpty();  
  public abstract boolean contains(java.lang.Object);
  public abstract java.util.Iterator<E> iterator();
  public abstract java.lang.Object[] toArray();
  public abstract <T> T[] toArray(T[]);
  public default <T> T[] toArray(java.util.function.IntFunction<T[]>);      
  public abstract boolean add(E);     
  public abstract boolean remove(java.lang.Object);
  public abstract boolean containsAll(java.util.Collection<?>);
  public abstract boolean addAll(java.util.Collection<? extends E>);        
  public abstract boolean removeAll(java.util.Collection<?>);
  public default boolean removeIf(java.util.function.Predicate<? super E>); 
  public abstract boolean retainAll(java.util.Collection<?>);
  public abstract void clear();       
  public abstract boolean equals(java.lang.Object);
  public abstract int hashCode();     
  public default java.util.Spliterator<E> spliterator();
  public default java.util.stream.Stream<E> stream();
  public default java.util.stream.Stream<E> parallelStream();
}

================================================================================================================================================

PS A:\> javap java.util.List    
Compiled from "List.java"
public interface java.util.List<E> extends java.util.Collection<E> {
  public abstract int size();
  public abstract boolean isEmpty();
  public abstract boolean contains(java.lang.Object);
  public abstract java.util.Iterator<E> iterator();
  public abstract java.lang.Object[] toArray();
  public abstract <T> T[] toArray(T[]);
  public abstract boolean add(E);
  public abstract boolean remove(java.lang.Object);
  public abstract boolean containsAll(java.util.Collection<?>);
  public abstract boolean addAll(java.util.Collection<? extends E>);
  public abstract boolean addAll(int, java.util.Collection<? extends E>);
  public abstract boolean removeAll(java.util.Collection<?>);
  public abstract boolean retainAll(java.util.Collection<?>);
  public default void replaceAll(java.util.function.UnaryOperator<E>);
  public default void sort(java.util.Comparator<? super E>);
  public abstract void clear();
  public abstract boolean equals(java.lang.Object);
  public abstract int hashCode();
  public abstract E get(int);
  public abstract E set(int, E);      
  public abstract void add(int, E);   
  public abstract E remove(int);      
  public abstract int indexOf(java.lang.Object);
  public abstract int lastIndexOf(java.lang.Object);
  public abstract java.util.ListIterator<E> listIterator();
  public abstract java.util.ListIterator<E> listIterator(int);
  public abstract java.util.List<E> subList(int, int);
  public default java.util.Spliterator<E> spliterator();
  public static <E> java.util.List<E> of();
  public static <E> java.util.List<E> of(E);
  public static <E> java.util.List<E> of(E, E);
  public static <E> java.util.List<E> of(E, E, E);
  public static <E> java.util.List<E> of(E, E, E, E);
  public static <E> java.util.List<E> of(E, E, E, E, E);
  public static <E> java.util.List<E> of(E, E, E, E, E, E);
  public static <E> java.util.List<E> of(E, E, E, E, E, E, E);
  public static <E> java.util.List<E> of(E, E, E, E, E, E, E, E);
  public static <E> java.util.List<E> of(E, E, E, E, E, E, E, E, E);        
  public static <E> java.util.List<E> of(E, E, E, E, E, E, E, E, E, E);     
  public static <E> java.util.List<E> of(E...);
  public static <E> java.util.List<E> copyOf(java.util.Collection<? extends E>);
}

================================================================================================================================================

PS A:\> javap java.util.LinkedList
Compiled from "LinkedList.java"
public class java.util.LinkedList<E> extends java.util.AbstractSequentialList<E> implements java.util.List<E>, java.util.Deque<E>, java.lang.Cloneable, java.io.Serializable {
  transient int size;
  transient java.util.LinkedList$Node<E> first;
  transient java.util.LinkedList$Node<E> last;
  public java.util.LinkedList();      
  public java.util.LinkedList(java.util.Collection<? extends E>);
  void linkLast(E);
  void linkBefore(E, java.util.LinkedList$Node<E>);
  E unlink(java.util.LinkedList$Node<E>);
  public E getFirst();
  public E getLast();
  public E removeFirst();
  public E removeLast();
  public void addFirst(E);
  public void addLast(E);
  public boolean contains(java.lang.Object);
  public int size();
  public boolean add(E);
  public boolean remove(java.lang.Object);
  public boolean addAll(java.util.Collection<? extends E>);
  public boolean addAll(int, java.util.Collection<? extends E>);
  public void clear();
  public E get(int);
  public E set(int, E);
  public void add(int, E);
  public E remove(int);
  java.util.LinkedList$Node<E> node(int);
  public int indexOf(java.lang.Object);
  public int lastIndexOf(java.lang.Object);
  public E peek();
  public E element();
  public E poll();
  public E remove();
  public boolean offer(E);
  public boolean offerFirst(E);       
  public boolean offerLast(E);        
  public E peekFirst();
  public E peekLast();
  public E pollFirst();
  public E pollLast();
  public void push(E);
  public E pop();
  public boolean removeFirstOccurrence(java.lang.Object);
  public boolean removeLastOccurrence(java.lang.Object);
  public java.util.ListIterator<E> listIterator(int);
  public java.util.Iterator<E> descendingIterator();
  public java.lang.Object clone();    
  public java.lang.Object[] toArray();
  public <T> T[] toArray(T[]);        
  public java.util.Spliterator<E> spliterator();
}

================================================================================================================================================

PS A:\> javap java.util.ArrayList 
Compiled from "ArrayList.java"
public class java.util.ArrayList<E> extends java.util.AbstractList<E> implements java.util.List<E>, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable {
  transient java.lang.Object[] elementData;
  public java.util.ArrayList(int);    
  public java.util.ArrayList();       
  public java.util.ArrayList(java.util.Collection<? extends E>);
  public void trimToSize();
  public void ensureCapacity(int);    
  public int size();
  public boolean isEmpty();
  public boolean contains(java.lang.Object);
  public int indexOf(java.lang.Object);
  int indexOfRange(java.lang.Object, int, int);
  public int lastIndexOf(java.lang.Object);
  int lastIndexOfRange(java.lang.Object, int, int);
  public java.lang.Object clone();    
  public java.lang.Object[] toArray();
  public <T> T[] toArray(T[]);        
  E elementData(int);
  static <E> E elementAt(java.lang.Object[], int);
  public E get(int);
  public E set(int, E);
  public boolean add(E);
  public void add(int, E);
  public E remove(int);
  public boolean equals(java.lang.Object);
  boolean equalsRange(java.util.List<?>, int, int);
  public int hashCode();
  int hashCodeRange(int, int);        
  public boolean remove(java.lang.Object);
  public void clear();
  public boolean addAll(java.util.Collection<? extends E>);
  public boolean addAll(int, java.util.Collection<? extends E>);
  protected void removeRange(int, int);
  public boolean removeAll(java.util.Collection<?>);
  public boolean retainAll(java.util.Collection<?>);
  boolean batchRemove(java.util.Collection<?>, boolean, int, int);
  public java.util.ListIterator<E> listIterator(int);
  public java.util.ListIterator<E> listIterator();
  public java.util.Iterator<E> iterator();
  public java.util.List<E> subList(int, int);
  public void forEach(java.util.function.Consumer<? super E>);
  public java.util.Spliterator<E> spliterator();
  public boolean removeIf(java.util.function.Predicate<? super E>);
  boolean removeIf(java.util.function.Predicate<? super E>, int, int);      
  public void replaceAll(java.util.function.UnaryOperator<E>);
  public void sort(java.util.Comparator<? super E>);
  void checkInvariants();
  static {};
}

================================================================================================================================================

PS A:\> javap java.util.Vector  
Compiled from "Vector.java"
public class java.util.Vector<E> extends java.util.AbstractList<E> implements java.util.List<E>, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable {
  protected java.lang.Object[] elementData;
  protected int elementCount;
  protected int capacityIncrement;    
  public java.util.Vector(int, int);  
  public java.util.Vector(int);       
  public java.util.Vector();
  public java.util.Vector(java.util.Collection<? extends E>);
  public synchronized void copyInto(java.lang.Object[]);
  public synchronized void trimToSize();
  public synchronized void ensureCapacity(int);
  public synchronized void setSize(int);
  public synchronized int capacity(); 
  public synchronized int size();     
  public synchronized boolean isEmpty();
  public java.util.Enumeration<E> elements();
  public boolean contains(java.lang.Object);
  public int indexOf(java.lang.Object);
  public synchronized int indexOf(java.lang.Object, int);
  public synchronized int lastIndexOf(java.lang.Object);
  public synchronized int lastIndexOf(java.lang.Object, int);
  public synchronized E elementAt(int);
  public synchronized E firstElement();
  public synchronized E lastElement();
  public synchronized void setElementAt(E, int);
  public synchronized void removeElementAt(int);
  public synchronized void insertElementAt(E, int);
  public synchronized void addElement(E);
  public synchronized boolean removeElement(java.lang.Object);
  public synchronized void removeAllElements();
  public synchronized java.lang.Object clone();
  public synchronized java.lang.Object[] toArray();
  public synchronized <T> T[] toArray(T[]);
  E elementData(int);
  static <E> E elementAt(java.lang.Object[], int);
  public synchronized E get(int);     
  public synchronized E set(int, E);  
  public synchronized boolean add(E); 
  public boolean remove(java.lang.Object);
  public void add(int, E);
  public synchronized E remove(int);  
  public void clear();
  public synchronized boolean containsAll(java.util.Collection<?>);
  public boolean addAll(java.util.Collection<? extends E>);
  public boolean removeAll(java.util.Collection<?>);
  public boolean retainAll(java.util.Collection<?>);
  public boolean removeIf(java.util.function.Predicate<? super E>);
  public synchronized boolean addAll(int, java.util.Collection<? extends E>);
  public synchronized boolean equals(java.lang.Object);
  public synchronized int hashCode(); 
  public synchronized java.lang.String toString();
  public synchronized java.util.List<E> subList(int, int);
  protected synchronized void removeRange(int, int);
  public synchronized java.util.ListIterator<E> listIterator(int);
  public synchronized java.util.ListIterator<E> listIterator();
  public synchronized java.util.Iterator<E> iterator();
  public synchronized void forEach(java.util.function.Consumer<? super E>); 
  public synchronized void replaceAll(java.util.function.UnaryOperator<E>); 
  public synchronized void sort(java.util.Comparator<? super E>);
  public java.util.Spliterator<E> spliterator();
  void checkInvariants();
}

================================================================================================================================================

PS A:\> javap java.util.Stack 
Compiled from "Stack.java"
public class java.util.Stack<E> extends java.util.Vector<E> {
  public java.util.Stack();
  public E push(E);
  public synchronized E pop();        
  public synchronized E peek();       
  public boolean empty();
  public synchronized int search(java.lang.Object);
}

================================================================================================================================================

PS A:\> javap java.util.AbstractList
Compiled from "AbstractList.java"
public abstract class java.util.AbstractList<E> extends java.util.AbstractCollection<E> implements java.util.List<E> {
  protected transient int modCount;   
  protected java.util.AbstractList(); 
  public boolean add(E);
  public abstract E get(int);
  public E set(int, E);
  public void add(int, E);
  public E remove(int);
  public int indexOf(java.lang.Object);
  public int lastIndexOf(java.lang.Object);
  public void clear();
  public boolean addAll(int, java.util.Collection<? extends E>);
  public java.util.Iterator<E> iterator();
  public java.util.ListIterator<E> listIterator();
  public java.util.ListIterator<E> listIterator(int);
  public java.util.List<E> subList(int, int);
  static void subListRangeCheck(int, int, int);
  public boolean equals(java.lang.Object);
  public int hashCode();
  protected void removeRange(int, int);
}

================================================================================================================================================

PS A:\> javap java.util.AbstractSequentialList
Compiled from "AbstractSequentialList.java"
public abstract class java.util.AbstractSequentialList<E> extends java.util.AbstractList<E> {
  protected java.util.AbstractSequentialList();
  public E get(int);
  public E set(int, E);
  public void add(int, E);
  public E remove(int);
  public boolean addAll(int, java.util.Collection<? extends E>);
  public java.util.Iterator<E> iterator();
  public abstract java.util.ListIterator<E> listIterator(int);
}
================================================================================================================================================

PS A:\> javap java.util.AbstractCollection    
Compiled from "AbstractCollection.java"
public abstract class java.util.AbstractCollection<E> implements java.util.Collection<E> {
  protected java.util.AbstractCollection();
  public abstract java.util.Iterator<E> iterator();
  public abstract int size();
  public boolean isEmpty();
  public boolean contains(java.lang.Object);
  public java.lang.Object[] toArray();
  public <T> T[] toArray(T[]);
  public boolean add(E);
  public boolean remove(java.lang.Object);
  public boolean containsAll(java.util.Collection<?>);
  public boolean addAll(java.util.Collection<? extends E>);
  public boolean removeAll(java.util.Collection<?>);
  public boolean retainAll(java.util.Collection<?>);
  public void clear();
  public java.lang.String toString();
}
================================================================================================================================================

PS A:\> javap java.util.Set     
Compiled from "Set.java"
public interface java.util.Set<E> extends java.util.Collection<E> {
  public abstract int size();
  public abstract boolean isEmpty();
  public abstract boolean contains(java.lang.Object);
  public abstract java.util.Iterator<E> iterator();
  public abstract java.lang.Object[] toArray();
  public abstract <T> T[] toArray(T[]);
  public abstract boolean add(E);
  public abstract boolean remove(java.lang.Object);
  public abstract boolean containsAll(java.util.Collection<?>);
  public abstract boolean addAll(java.util.Collection<? extends E>);
  public abstract boolean retainAll(java.util.Collection<?>);
  public abstract boolean removeAll(java.util.Collection<?>);
  public abstract void clear();
  public abstract boolean equals(java.lang.Object);
  public abstract int hashCode();
  public default java.util.Spliterator<E> spliterator();
  public static <E> java.util.Set<E> of();
  public static <E> java.util.Set<E> of(E);
  public static <E> java.util.Set<E> of(E, E);
  public static <E> java.util.Set<E> of(E, E, E);
  public static <E> java.util.Set<E> of(E, E, E, E);
  public static <E> java.util.Set<E> of(E, E, E, E, E);
  public static <E> java.util.Set<E> of(E, E, E, E, E, E);
  public static <E> java.util.Set<E> of(E, E, E, E, E, E, E);
  public static <E> java.util.Set<E> of(E, E, E, E, E, E, E, E);
  public static <E> java.util.Set<E> of(E, E, E, E, E, E, E, E, E);
  public static <E> java.util.Set<E> of(E, E, E, E, E, E, E, E, E, E);      
  public static <E> java.util.Set<E> of(E...);
  public static <E> java.util.Set<E> copyOf(java.util.Collection<? extends E>);
}
================================================================================================================================================

PS A:\> javap java.util.AbstractSet  
Compiled from "AbstractSet.java"
public abstract class java.util.AbstractSet<E> extends java.util.AbstractCollection<E> implements java.util.Set<E> {
  protected java.util.AbstractSet();  
  public boolean equals(java.lang.Object);
  public int hashCode();
  public boolean removeAll(java.util.Collection<?>);
}
================================================================================================================================================

PS A:\> javap java.util.HashSet
Compiled from "HashSet.java"
public class java.util.HashSet<E> extends java.util.AbstractSet<E> implements java.util.Set<E>, java.lang.Cloneable, java.io.Serializable {
  static final long serialVersionUID; 
  public java.util.HashSet();
  public java.util.HashSet(java.util.Collection<? extends E>);
  public java.util.HashSet(int, float);
  public java.util.HashSet(int);      
  java.util.HashSet(int, float, boolean);
  public java.util.Iterator<E> iterator();
  public int size();
  public boolean isEmpty();
  public boolean contains(java.lang.Object);
  public boolean add(E);
  public boolean remove(java.lang.Object);
  public void clear();
  public java.lang.Object clone();    
  public java.util.Spliterator<E> spliterator();
  public java.lang.Object[] toArray();
  public <T> T[] toArray(T[]);        
  static {};
}
================================================================================================================================================

PS A:\> javap java.util.LinkedHashSet
Compiled from "LinkedHashSet.java"
public class java.util.LinkedHashSet<E> extends java.util.HashSet<E> implements java.util.Set<E>, java.lang.Cloneable, java.io.Serializable {
  public java.util.LinkedHashSet(int, float);
  public java.util.LinkedHashSet(int);
  public java.util.LinkedHashSet();   
  public java.util.LinkedHashSet(java.util.Collection<? extends E>);        
  public java.util.Spliterator<E> spliterator();
}
================================================================================================================================================

PS A:\> javap java.util.SortedSet  
Compiled from "SortedSet.java"
public interface java.util.SortedSet<E> extends java.util.Set<E> {
  public abstract java.util.Comparator<? super E> comparator();
  public abstract java.util.SortedSet<E> subSet(E, E);
  public abstract java.util.SortedSet<E> headSet(E);
  public abstract java.util.SortedSet<E> tailSet(E);
  public abstract E first();
  public abstract E last();
  public default java.util.Spliterator<E> spliterator();
}
================================================================================================================================================

PS A:\> javap java.util.NavigableSet
Compiled from "NavigableSet.java"
public interface java.util.NavigableSet<E> extends java.util.SortedSet<E> { 
  public abstract E lower(E);
  public abstract E floor(E);
  public abstract E ceiling(E);       
  public abstract E higher(E);        
  public abstract E pollFirst();      
  public abstract E pollLast();       
  public abstract java.util.Iterator<E> iterator();
  public abstract java.util.NavigableSet<E> descendingSet();
  public abstract java.util.Iterator<E> descendingIterator();
  public abstract java.util.NavigableSet<E> subSet(E, boolean, E, boolean); 
  public abstract java.util.NavigableSet<E> headSet(E, boolean);
  public abstract java.util.NavigableSet<E> tailSet(E, boolean);
  public abstract java.util.SortedSet<E> subSet(E, E);
  public abstract java.util.SortedSet<E> headSet(E);
  public abstract java.util.SortedSet<E> tailSet(E);
}
================================================================================================================================================

PS A:\> javap java.util.TreeSet 
Compiled from "TreeSet.java"
public class java.util.TreeSet<E> extends java.util.AbstractSet<E> implements java.util.NavigableSet<E>, java.lang.Cloneable, java.io.Serializable {    
  java.util.TreeSet(java.util.NavigableMap<E, java.lang.Object>);
  public java.util.TreeSet();
  public java.util.TreeSet(java.util.Comparator<? super E>);
  public java.util.TreeSet(java.util.Collection<? extends E>);
  public java.util.TreeSet(java.util.SortedSet<E>);
  public java.util.Iterator<E> iterator();
  public java.util.Iterator<E> descendingIterator();
  public java.util.NavigableSet<E> descendingSet();
  public int size();
  public boolean isEmpty();
  public boolean contains(java.lang.Object);
  public boolean add(E);
  public boolean remove(java.lang.Object);
  public void clear();
  public boolean addAll(java.util.Collection<? extends E>);
  public java.util.NavigableSet<E> subSet(E, boolean, E, boolean);
  public java.util.NavigableSet<E> headSet(E, boolean);
  public java.util.NavigableSet<E> tailSet(E, boolean);
  public java.util.SortedSet<E> subSet(E, E);
  public java.util.SortedSet<E> headSet(E);
  public java.util.SortedSet<E> tailSet(E);
  public java.util.Comparator<? super E> comparator();
  public E first();
  public E last();
  public E lower(E);
  public E floor(E);
  public E ceiling(E);
  public E higher(E);
  public E pollFirst();
  public E pollLast();
  public java.lang.Object clone();    
  public java.util.Spliterator<E> spliterator();
  static {};
}
================================================================================================================================================

PS A:\> javap java.util.Queue  
Compiled from "Queue.java"
public interface java.util.Queue<E> extends java.util.Collection<E> {       
  public abstract boolean add(E);     
  public abstract boolean offer(E);   
  public abstract E remove();
  public abstract E poll();
  public abstract E element();        
  public abstract E peek();
}
================================================================================================================================================

PS A:\> javap java.util.PriorityQueue
Compiled from "PriorityQueue.java"
public class java.util.PriorityQueue<E> extends java.util.AbstractQueue<E> implements java.io.Serializable {      
  transient java.lang.Object[] queue; 
  int size;
  transient int modCount;
  public java.util.PriorityQueue();   
  public java.util.PriorityQueue(int);
  public java.util.PriorityQueue(java.util.Comparator<? super E>);
  public java.util.PriorityQueue(int, java.util.Comparator<? super E>);     
  public java.util.PriorityQueue(java.util.Collection<? extends E>);        
  public java.util.PriorityQueue(java.util.PriorityQueue<? extends E>);     
  public java.util.PriorityQueue(java.util.SortedSet<? extends E>);
  public boolean add(E);
  public boolean offer(E);
  public E peek();
  public boolean remove(java.lang.Object);
  void removeEq(java.lang.Object);    
  public boolean contains(java.lang.Object);
  public java.lang.Object[] toArray();
  public <T> T[] toArray(T[]);        
  public java.util.Iterator<E> iterator();
  public int size();
  public void clear();
  public E poll();
  E removeAt(int);
  public java.util.Comparator<? super E> comparator();
  public final java.util.Spliterator<E> spliterator();
  public boolean removeIf(java.util.function.Predicate<? super E>);
  public boolean removeAll(java.util.Collection<?>);
  public boolean retainAll(java.util.Collection<?>);
  public void forEach(java.util.function.Consumer<? super E>);
}
================================================================================================================================================

PS A:\> javap java.util.Deque  
Compiled from "Deque.java"
public interface java.util.Deque<E> extends java.util.Queue<E> {
  public abstract void addFirst(E);   
  public abstract void addLast(E);    
  public abstract boolean offerFirst(E);
  public abstract boolean offerLast(E);
  public abstract E removeFirst();    
  public abstract E removeLast();     
  public abstract E pollFirst();      
  public abstract E pollLast();       
  public abstract E getFirst();       
  public abstract E getLast();        
  public abstract E peekFirst();      
  public abstract E peekLast();       
  public abstract boolean removeFirstOccurrence(java.lang.Object);
  public abstract boolean removeLastOccurrence(java.lang.Object);
  public abstract boolean add(E);     
  public abstract boolean offer(E);   
  public abstract E remove();
  public abstract E poll();
  public abstract E element();        
  public abstract E peek();
  public abstract boolean addAll(java.util.Collection<? extends E>);        
  public abstract void push(E);       
  public abstract E pop();
  public abstract boolean remove(java.lang.Object);
  public abstract boolean contains(java.lang.Object);
  public abstract int size();
  public abstract java.util.Iterator<E> iterator();
  public abstract java.util.Iterator<E> descendingIterator();
}
================================================================================================================================================

PS A:\> javap java.util.AbstractQueue
Compiled from "AbstractQueue.java"
public abstract class java.util.AbstractQueue<E> extends java.util.AbstractCollection<E> implements java.util.Queue<E> {
  protected java.util.AbstractQueue();
  public boolean add(E);
  public E remove();
  public E element();
  public void clear();
  public boolean addAll(java.util.Collection<? extends E>);
}
================================================================================================================================================

PS A:\> javap java.util.Map    
Compiled from "Map.java"
public interface java.util.Map<K, V> {
  public abstract int size();
  public abstract boolean isEmpty();  
  public abstract boolean containsKey(java.lang.Object);
  public abstract boolean containsValue(java.lang.Object);
  public abstract V get(java.lang.Object);
  public abstract V put(K, V);        
  public abstract V remove(java.lang.Object);
  public abstract void putAll(java.util.Map<? extends K, ? extends V>);     
  public abstract void clear();       
  public abstract java.util.Set<K> keySet();
  public abstract java.util.Collection<V> values();
  public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();      
  public abstract boolean equals(java.lang.Object);
  public abstract int hashCode();     
  public default V getOrDefault(java.lang.Object, V);
  public default void forEach(java.util.function.BiConsumer<? super K, ? super V>);
  public default void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public default V putIfAbsent(K, V); 
  public default boolean remove(java.lang.Object, java.lang.Object);        
  public default boolean replace(K, V, V);
  public default V replace(K, V);     
  public default V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
  public default V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public default V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public default V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
  public static <K, V> java.util.Map<K, V> of();
  public static <K, V> java.util.Map<K, V> of(K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V);      
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);        
  public static <K, V> java.util.Map<K, V> ofEntries(java.util.Map$Entry<? extends K, ? extends V>...);
  public static <K, V> java.util.Map$Entry<K, V> entry(K, V);
  public static <K, V> java.util.Map<K, V> copyOf(java.util.Map<? extends K, ? extends V>);
}
================================================================================================================================================

PS A:\> javap java.util.HashMap
Compiled from "HashMap.java"
public class java.util.HashMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.Map<K, V>, java.lang.Cloneable, java.io.Serializable {    
  static final int DEFAULT_INITIAL_CAPACITY;
  static final int MAXIMUM_CAPACITY;  
  static final float DEFAULT_LOAD_FACTOR;
  static final int TREEIFY_THRESHOLD; 
  static final int UNTREEIFY_THRESHOLD;
  static final int MIN_TREEIFY_CAPACITY;
  transient java.util.HashMap$Node<K, V>[] table;
  transient java.util.Set<java.util.Map$Entry<K, V>> entrySet;
  transient int size;
  transient int modCount;
  int threshold;
  final float loadFactor;
  static final int hash(java.lang.Object);
  static java.lang.Class<?> comparableClassFor(java.lang.Object);
  static int compareComparables(java.lang.Class<?>, java.lang.Object, java.lang.Object);
  static final int tableSizeFor(int); 
  public java.util.HashMap(int, float);
  public java.util.HashMap(int);      
  public java.util.HashMap();
  public java.util.HashMap(java.util.Map<? extends K, ? extends V>);        
  final void putMapEntries(java.util.Map<? extends K, ? extends V>, boolean);
  public int size();
  public boolean isEmpty();
  public V get(java.lang.Object);     
  final java.util.HashMap$Node<K, V> getNode(java.lang.Object);
  public boolean containsKey(java.lang.Object);
  public V put(K, V);
  final V putVal(int, K, V, boolean, boolean);
  final java.util.HashMap$Node<K, V>[] resize();
  final void treeifyBin(java.util.HashMap$Node<K, V>[], int);
  public void putAll(java.util.Map<? extends K, ? extends V>);
  public V remove(java.lang.Object);  
  final java.util.HashMap$Node<K, V> removeNode(int, java.lang.Object, java.lang.Object, boolean, boolean);       
  public void clear();
  public boolean containsValue(java.lang.Object);
  public java.util.Set<K> keySet();   
  final <T> T[] prepareArray(T[]);    
  <T> T[] keysToArray(T[]);
  <T> T[] valuesToArray(T[]);
  public java.util.Collection<V> values();
  public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
  public V getOrDefault(java.lang.Object, V);
  public V putIfAbsent(K, V);
  public boolean remove(java.lang.Object, java.lang.Object);
  public boolean replace(K, V, V);    
  public V replace(K, V);
  public V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
  public V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
  public void forEach(java.util.function.BiConsumer<? super K, ? super V>); 
  public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public java.lang.Object clone();    
  final float loadFactor();
  final int capacity();
  java.util.HashMap$Node<K, V> newNode(int, K, V, java.util.HashMap$Node<K, V>);
  java.util.HashMap$Node<K, V> replacementNode(java.util.HashMap$Node<K, V>, java.util.HashMap$Node<K, V>);       
  java.util.HashMap$TreeNode<K, V> newTreeNode(int, K, V, java.util.HashMap$Node<K, V>);
  java.util.HashMap$TreeNode<K, V> replacementTreeNode(java.util.HashMap$Node<K, V>, java.util.HashMap$Node<K, V>);
  void reinitialize();
  void afterNodeAccess(java.util.HashMap$Node<K, V>);
  void afterNodeInsertion(boolean);   
  void afterNodeRemoval(java.util.HashMap$Node<K, V>);
  void internalWriteEntries(java.io.ObjectOutputStream) throws java.io.IOException;
}
================================================================================================================================================

PS A:\> javap java.util.AbstractMap
Compiled from "AbstractMap.java"
public abstract class java.util.AbstractMap<K, V> implements java.util.Map<K, V> {
  transient java.util.Set<K> keySet;  
  transient java.util.Collection<V> values;
  protected java.util.AbstractMap();  
  public int size();
  public boolean isEmpty();
  public boolean containsValue(java.lang.Object);
  public boolean containsKey(java.lang.Object);
  public V get(java.lang.Object);     
  public V put(K, V);
  public V remove(java.lang.Object);  
  public void putAll(java.util.Map<? extends K, ? extends V>);
  public void clear();
  public java.util.Set<K> keySet();   
  public java.util.Collection<V> values();
  public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();      
  public boolean equals(java.lang.Object);
  public int hashCode();
  public java.lang.String toString(); 
  protected java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
================================================================================================================================================

PS A:\> javap java.util.SortedMap  
Compiled from "SortedMap.java"
public interface java.util.SortedMap<K, V> extends java.util.Map<K, V> {    
  public abstract java.util.Comparator<? super K> comparator();
  public abstract java.util.SortedMap<K, V> subMap(K, K);
  public abstract java.util.SortedMap<K, V> headMap(K);
  public abstract java.util.SortedMap<K, V> tailMap(K);
  public abstract K firstKey();       
  public abstract K lastKey();        
  public abstract java.util.Set<K> keySet();
  public abstract java.util.Collection<V> values();
  public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();      
}
================================================================================================================================================

PS A:\> javap java.util.TreeMap 
Compiled from "TreeMap.java"
public class java.util.TreeMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.NavigableMap<K, V>, java.lang.Cloneable, java.io.Serializable {
  public java.util.TreeMap();
  public java.util.TreeMap(java.util.Comparator<? super K>);
  public java.util.TreeMap(java.util.Map<? extends K, ? extends V>);        
  public java.util.TreeMap(java.util.SortedMap<K, ? extends V>);
  public int size();
  public boolean containsKey(java.lang.Object);
  public boolean containsValue(java.lang.Object);
  public V get(java.lang.Object);     
  public java.util.Comparator<? super K> comparator();
  public K firstKey();
  public K lastKey();
  public void putAll(java.util.Map<? extends K, ? extends V>);
  final java.util.TreeMap$Entry<K, V> getEntry(java.lang.Object);
  final java.util.TreeMap$Entry<K, V> getEntryUsingComparator(java.lang.Object);
  final java.util.TreeMap$Entry<K, V> getCeilingEntry(K);
  final java.util.TreeMap$Entry<K, V> getFloorEntry(K);
  final java.util.TreeMap$Entry<K, V> getHigherEntry(K);
  final java.util.TreeMap$Entry<K, V> getLowerEntry(K);
  public V put(K, V);
  public V putIfAbsent(K, V);
  public V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
  public V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
  public V remove(java.lang.Object);  
  public void clear();
  public java.lang.Object clone();    
  public java.util.Map$Entry<K, V> firstEntry();
  public java.util.Map$Entry<K, V> lastEntry();
  public java.util.Map$Entry<K, V> pollFirstEntry();
  public java.util.Map$Entry<K, V> pollLastEntry();
  public java.util.Map$Entry<K, V> lowerEntry(K);
  public K lowerKey(K);
  public java.util.Map$Entry<K, V> floorEntry(K);
  public K floorKey(K);
  public java.util.Map$Entry<K, V> ceilingEntry(K);
  public K ceilingKey(K);
  public java.util.Map$Entry<K, V> higherEntry(K);
  public K higherKey(K);
  public java.util.Set<K> keySet();   
  public java.util.NavigableSet<K> navigableKeySet();
  public java.util.NavigableSet<K> descendingKeySet();
  public java.util.Collection<V> values();
  public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
  public java.util.NavigableMap<K, V> descendingMap();
  public java.util.NavigableMap<K, V> subMap(K, boolean, K, boolean);       
  public java.util.NavigableMap<K, V> headMap(K, boolean);
  public java.util.NavigableMap<K, V> tailMap(K, boolean);
  public java.util.SortedMap<K, V> subMap(K, K);
  public java.util.SortedMap<K, V> headMap(K);
  public java.util.SortedMap<K, V> tailMap(K);
  public boolean replace(K, V, V);    
  public V replace(K, V);
  public void forEach(java.util.function.BiConsumer<? super K, ? super V>); 
  public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  java.util.Iterator<K> keyIterator();
  java.util.Iterator<K> descendingKeyIterator();
  final int compare(java.lang.Object, java.lang.Object);
  static final boolean valEquals(java.lang.Object, java.lang.Object);       
  static <K, V> java.util.Map$Entry<K, V> exportEntry(java.util.TreeMap$Entry<K, V>);
  static <K, V> K keyOrNull(java.util.TreeMap$Entry<K, V>);
  static <K> K key(java.util.TreeMap$Entry<K, ?>);
  final java.util.TreeMap$Entry<K, V> getFirstEntry();
  final java.util.TreeMap$Entry<K, V> getLastEntry();
  static <K, V> java.util.TreeMap$Entry<K, V> successor(java.util.TreeMap$Entry<K, V>);
  static <K, V> java.util.TreeMap$Entry<K, V> predecessor(java.util.TreeMap$Entry<K, V>);
  void readTreeSet(int, java.io.ObjectInputStream, V) throws java.io.IOException, java.lang.ClassNotFoundException;
  void addAllForTreeSet(java.util.SortedSet<? extends K>, V);
  static <K> java.util.Spliterator<K> keySpliteratorFor(java.util.NavigableMap<K, ?>);
  final java.util.Spliterator<K> keySpliterator();
  final java.util.Spliterator<K> descendingKeySpliterator();
  static {};
}
================================================================================================================================================

PS A:\> javap java.util.NavigableMap
Compiled from "NavigableMap.java"
public interface java.util.NavigableMap<K, V> extends java.util.SortedMap<K, V> {
  public abstract java.util.Map$Entry<K, V> lowerEntry(K);
  public abstract K lowerKey(K);      
  public abstract java.util.Map$Entry<K, V> floorEntry(K);
  public abstract K floorKey(K);      
  public abstract java.util.Map$Entry<K, V> ceilingEntry(K);
  public abstract K ceilingKey(K);    
  public abstract java.util.Map$Entry<K, V> higherEntry(K);
  public abstract K higherKey(K);     
  public abstract java.util.Map$Entry<K, V> firstEntry();
  public abstract java.util.Map$Entry<K, V> lastEntry();
  public abstract java.util.Map$Entry<K, V> pollFirstEntry();
  public abstract java.util.Map$Entry<K, V> pollLastEntry();
  public abstract java.util.NavigableMap<K, V> descendingMap();
  public abstract java.util.NavigableSet<K> navigableKeySet();
  public abstract java.util.NavigableSet<K> descendingKeySet();
  public abstract java.util.NavigableMap<K, V> subMap(K, boolean, K, boolean);
  public abstract java.util.NavigableMap<K, V> headMap(K, boolean);
  public abstract java.util.NavigableMap<K, V> tailMap(K, boolean);
  public abstract java.util.SortedMap<K, V> subMap(K, K);
  public abstract java.util.SortedMap<K, V> headMap(K);
  public abstract java.util.SortedMap<K, V> tailMap(K);
}
================================================================================================================================================

PS A:\> javap java.util.LinkedHashMap
Compiled from "LinkedHashMap.java"
public class java.util.LinkedHashMap<K, V> extends java.util.HashMap<K, V> implements java.util.Map<K, V> {
  transient java.util.LinkedHashMap$Entry<K, V> head;
  transient java.util.LinkedHashMap$Entry<K, V> tail;
  final boolean accessOrder;
  void reinitialize();
  java.util.HashMap$Node<K, V> newNode(int, K, V, java.util.HashMap$Node<K, V>);
  java.util.HashMap$Node<K, V> replacementNode(java.util.HashMap$Node<K, V>, java.util.HashMap$Node<K, V>);
  java.util.HashMap$TreeNode<K, V> newTreeNode(int, K, V, java.util.HashMap$Node<K, V>);
  java.util.HashMap$TreeNode<K, V> replacementTreeNode(java.util.HashMap$Node<K, V>, java.util.HashMap$Node<K, V>);
  void afterNodeRemoval(java.util.HashMap$Node<K, V>);
  void afterNodeInsertion(boolean);
  void afterNodeAccess(java.util.HashMap$Node<K, V>);
  void internalWriteEntries(java.io.ObjectOutputStream) throws java.io.IOException;
  public java.util.LinkedHashMap(int, float);
  public java.util.LinkedHashMap(int);
  public java.util.LinkedHashMap();   
  public java.util.LinkedHashMap(java.util.Map<? extends K, ? extends V>);  
  public java.util.LinkedHashMap(int, float, boolean);
  public boolean containsValue(java.lang.Object);
  public V get(java.lang.Object);     
  public V getOrDefault(java.lang.Object, V);
  public void clear();
  protected boolean removeEldestEntry(java.util.Map$Entry<K, V>);
  public java.util.Set<K> keySet();   
  final <T> T[] keysToArray(T[]);     
  final <T> T[] valuesToArray(T[]);   
  public java.util.Collection<V> values();
  public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
  public void forEach(java.util.function.BiConsumer<? super K, ? super V>); 
  public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
}
================================================================================================================================================
================================================================================================================================================
================================================================================================================================================
================================================================================================================================================